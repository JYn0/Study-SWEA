# SW 문제해결 응용



## [Learn > Course > Programming Advanced > 구현 > 시작하기]



##### 비트연산

| 연산자 |                   기능                   |      예      |
| :----: | :--------------------------------------: | :----------: |
|   &    |           비트단위로 AND 연산            | num1 & num2  |
|   \|   |            비트단위로 OR 연산            | num1 \| num2 |
|   ^    |   비트단위로 XOR연산 (같으면0 다르면1)   | num1 ^ num2  |
|   ~    | 단항 연산자, 피연산자의 모든 비트를 반전 |     ~num     |
|   >>   |    피연산자의 비트 열을 왼쪽으로 이동    |   num << 2   |
|   <<   |   피연산자의 비트 열을 오른쪽으로 이동   |   num >> 2   |



* << 정수 값을 왼쪽으로 시프트 : 곱한 결과

  2^n의 값을 가짐

  원소가 n개일 경우의 모든 부분집합의 수를 의미

  Power set(모든 부분 집합)

  * i & (1 << j)

    특정 위치의 비트 값이 1인지 0인지 판별하고 싶을 때 사용

    계산 결과 : i의 j번째 비트가 1인지 아닌지 의미

    ```C
    // 특정 위치의 비트값을 확인하는 수식
    void BitPrint(char i){
        for(int j=7; j>=0; j--){
            putchar((i & (1 << j)) ? '1' : '0');
            // print("%d", (i >> j) & 1);
        }
    }
    void main(void){
        char i;
        for(i=-5; i<6; i++){
            printf("%3d = ", i); // 십진수 출력
            BitPrint(i); // 이진수 출력
            putchar('\n');
        }
    }
    ```

  * 4바이트 크기의 인티저형 변수에 저장된 값들을 한 바이트씩 읽어서 비트형태로 출력

    ```C
    void main(void){
        char *p;
        char a = 0x10;
        int x = 0x01020304, i;
        printf("%d = ", a);
        p = &a;
        Bbit_print(*p);
        putchar('\n');
        printf("0%X = ", x);
        p = (char *) &x;
        for(i=0; i<4; i++){
            Bbit_print(*p++);
        }
        putchar('\n');
    }
    ```

* 엔디안(Endianness)

  컴퓨터의 메모리와 같은 일차원의 공간에 여러개의 연속된 대상을 배열하는 방법

  하드웨어(HW) 아키텍처마다 다름

  속도향상을위해 바이트단위와 워드단위변환 연산 시 올바로 이해하지 않으면 오류 발생

  * 빅 엔디안(Big-endian)

    보통 큰 단위가 앞에 나옴(네트워크)

  * 리틀 엔디안(Little-endian)

    작은 단위가 앞에 나옴(대다수의 데스크탑 컴퓨터)