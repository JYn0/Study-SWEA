# SW 문제해결 응용



## [Learn > Course > Programming Advanced > 구현 > 시작하기]



##### SW 문제 해결

* SW 문제 해결 역량은 프로그램 작성을 위한 많은 제약 조건들과 요구사항들을 이해하고 최선의 방법을 찾아내는 능력이 필요하다.
* 잘 정제된 추상적인 문제를 제시하고 이를 해결해 가면서 문제 해결 능력을 향상 시키는 훈련이 필요하다.



##### 알고리즘 복잡도

* 알고리즘을 설계하면 필요한 자원이 어르정도인지에 대한 효율성 분석이 필요하다.

  특히, 시간적 복잡도가 알고리즘의 효율성을 나타내는 주요한 요소이다.

* 시간 복잡도는 입력 크기에 대한 함수로 표기하고, 이 함수는 주로 여러개의 항을 가지는 다항식으로 표현한다.

* 이를 단순한 함수로 표한하기 위해 점근적 표기(Asymptotic Notation)를 사용한다.

  O(Big-Oh) , Ω(Big-Omega), Θ(Theta) 표기



##### 비트연산

| 연산자 |                   기능                   |      예      |
| :----: | :--------------------------------------: | :----------: |
|   &    |           비트단위로 AND 연산            | num1 & num2  |
|   \|   |            비트단위로 OR 연산            | num1 \| num2 |
|   ^    |   비트단위로 XOR연산 (같으면0 다르면1)   | num1 ^ num2  |
|   ~    | 단항 연산자, 피연산자의 모든 비트를 반전 |     ~num     |
|   >>   |    피연산자의 비트 열을 왼쪽으로 이동    |   num << 2   |
|   <<   |   피연산자의 비트 열을 오른쪽으로 이동   |   num >> 2   |



* << 정수 값을 왼쪽으로 시프트 : 곱한 결과

  2^n의 값을 가짐

  원소가 n개일 경우의 모든 부분집합의 수를 의미

  Power set(모든 부분 집합)

  * i & (1 << j)

    특정 위치의 비트 값이 1인지 0인지 판별하고 싶을 때 사용

    계산 결과 : i의 j번째 비트가 1인지 아닌지 의미

    ```C
    // 특정 위치의 비트값을 확인하는 수식
    void BitPrint(char i){
        for(int j=7; j>=0; j--){
            putchar((i & (1 << j)) ? '1' : '0');
            // print("%d", (i >> j) & 1);
        }
    }
    void main(void){
        char i;
        for(i=-5; i<6; i++){
            printf("%3d = ", i); // 십진수 출력
            BitPrint(i); // 이진수 출력
            putchar('\n');
        }
    }
    ```

  * 4바이트 크기의 인티저형 변수에 저장된 값들을 한 바이트씩 읽어서 비트형태로 출력

    ```C
    void main(void){
        char *p;
        char a = 0x10;
        int x = 0x01020304, i;
        printf("%d = ", a);
        p = &a;
        Bbit_print(*p);
        putchar('\n');
        printf("0%X = ", x);
        p = (char *) &x;
        for(i=0; i<4; i++){
            Bbit_print(*p++);
        }
        putchar('\n');
    }
    ```

* 엔디안(Endianness)

  컴퓨터의 메모리와 같은 일차원의 공간에 여러개의 연속된 대상을 배열하는 방법

  하드웨어(HW) 아키텍처마다 다름

  속도향상을위해 바이트단위와 워드단위변환 연산 시 올바로 이해하지 않으면 오류 발생

  * 빅 엔디안(Big-endian)

    보통 큰 단위가 앞에 나옴(네트워크)

  * 리틀 엔디안(Little-endian)

    작은 단위가 앞에 나옴(대다수의 데스크탑 컴퓨터)
  
* Byte Alignment

  프로세서의 성능 향상 -> 주소버스가 4의 배수형태의 주소만 access

  어떤 객체(4byte)가 4의 배수형 주소에 있지 않다면 메모리 access를 2번 해야함

  * 변수 별 저장 가능한 주소의 번지 패턴

    1byte 형: 모든 주소 번지에 기록 가능

    2byte 형: 2byte boundary에 정렬4

    byte 형: 4byte boundary에 정렬

    Double(8byte) 형: windows에서는 8byte, 리눅스에서는 4byte boundary

  * Structrue Byte Padding

    구조체의 멤버들 사이에 임의의 공간이 생기는 현상(padding byte)

    구조체의 경우 멤버 중 가장 큰 데이터 타입의 배수 값으로 크기가 결정

    구조체 멤버들의 순서를 잘 배치하면 필요한 메모리의 크기를 줄일 수 있음

* XOR

  배타적 논리합을 구하는 연산자

  비트 연산자 ^를 두번 연산하면 처음 값 반환



##### 진수

* 2진수, 8진수, 10진수, 16진수

* 컴퓨터에서 음의 정수 표현 방법

  * 1의 보수

    부호와 절대값으로 표현된 값을 부호 비트를 제외한 나머지 비트들을 0은 1로, 1은 0으로 변환

    -6 : 1000 0000 0000 0110 : 부호와 절대값 표현

    -6 : 1111 1111 1111 1001 : 1의 보수 표현

  * 2의 보수

    1의 보수방법으로 표현된 값의 최하위 비트에 1을 더함

    16 : 1111 1111 1111 1010 : 2의 보수 표현



##### 실수

* 컴퓨터에서 실수의 표현 방법

  부동 소수점(floating-point) 표기법 : 소수점의 위치를 고정시켜 표현하는 방식

  실수를 저장하기 위한 형식

  * 단정도 실수(32비트)

    부호 1비트 + 지수 8비트 + 가수 23비트

  * 배정도 실수(64비트)

    부호 1비트 + 지수 11비트 + 가수 52비트

  * 가수부(mantissa) : 실수의 유효 자릿수들을 부호화된 고정 소수점으로 표현한 것

    지수부(exponent) : 실제 소수점의 위치를 지수 승으로 표현한 것

  * 단정도 실수의 가수 부분을 만드는 방법

    예 1001.0011

    1. 정수부의 첫번째 자리가 1이 되도록 오른쪽으로 시프트 -> 0001.0010011
    2. 소수점 이하를 23비트로 만듦 -> 001.00100110000000000000000
    3. 소수점 이하만 가수 부분에 저장 -> 00100110000000000000000
    4. 지수 부분은 시프트 한 자릿수 만큼 증가 또는 감소 -> 1.0010011 X 2^3

  * 단정도 실수의 지수 부분을 만드는 방법

    지수부에는 8비트 배정(256개의 상태를 나타낼 수 있음)

    숫자로 0~255까지 표현 가능, 음수 값을 나타낼 수 있어야 하므로 익세스(excess) 표현법 사용

    ​	익세스(excess) 표현법 : 지수부의 값을 반으로 나누어 그 값을 0으로 간주하여 음수지수와 양수지수를 표현하는 방법

* 유효 숫자

  컴퓨터는 실수를 근사적으로 표현

  ​	정확한 십진수의 실수 값을 이진수로 표현할 수 없음

  ​	이진수로 표현할 수 없는 실수는 근사 값으로 저장

  ​	작은 오차가 계산 과정에서 다른 결과를 가져올 수 있음 -> 오차에 항상 주의

  실수 자료형 표현에서 가능한 유효 숫자의 자릿수를 알아 두는 게 좋음

  ​	32비트 실수형 유효자릿수(십진수) -> 6

  ​	64비트 실수형 유효자릿수(십진수) -> 15



## [Learn > Course > Programming Advanced > 구현 > 완전검색]



##### 완전검색

* 문제의 해(Solution)를 찾기 위해 가능한 모든 경우들을 나열해 보고 확인하는 기법

  문제를 해결하기 위한 가장 쉬운 접근법

  거의 대부분의 문제에 적용 가능

  주어진 문제의 자료의 수가 적거나 문제의 크기가 작을 때 유용

* 고지식한 방법(Brute-force)

  생성 및 테스트(Generate and Test)

* 순차검색(Sequential Search)

  리스트에서 키 값을 찾기 위한 완전 검색 방법



##### 조합적 문제

* 순열(Permutations)

  서로 다른 것들 중 몇 개를 뽑아서 한줄로 나열하는 것

  다수 문제들이 순서화된 요소들의 집합에서 최선의 경우를 찾는 것

  * 사전적 순서(Lexicographic-Order)

    요소들이 오름차순으로 나열된 형태가 시작하는 하나의 순열

  * 최소 변경을 통한 방법(Minimum-exchange Requirement)

    각 순열들은 이전에 생성된 순열에서 단지 두개의 요소들을 교환

  * 존슨-트로터 알고리즘(Johnson-Trotter Algorithm)

  * 두 원소의 교환을 통해 순열 생성

    트리를 순회하는 것과 같이 재귀호출을 통해 순열 생성

    트리의 단말에 도착하게 되면 하나의 순열이 생성

* 부분집합

  최적의 답이 전체 값들의 부분 집합인 알고리즘들이 존재
  
  * 바이너리 카운팅(Binary Counting)
  
    비트표현을 이용해서 부분집합을 생성하는 가장 자연스럽고 간단한 방법
  
    부분집합을 사전적 순서(Lexicographic Order)로 생성할때도 효과적
  
    ```C++
    int i;
    int arr[] = {3, 6, 7, 1, 5, 4};
    int n = sizeof(arr) / sizeof(arr[0]);
    
    for(num=0; num<(1<<n); num++){ // 1 << n 부분집합의 개수(2의 누승)
        for(i=0; i<n; i++){ // n(원소의 수)개의 비트를 검사
            if(num & (1<<i)){ // num의 i번재 비트 1인지 확인
                printf("%d, ", arr[i]);
            }
        }
        printf("\n";)
    }
    ```
  
* 조합(Combination)

  서로 다른 n개의 원소 중 r개를 순서 없이 골라낸 것

  ![c](https://user-images.githubusercontent.com/50862497/73509419-60183f00-4422-11ea-8f1c-f6e8e54d5ede.JPG)

  

## [Learn > Course > Programming Advanced > 구현 > 탐욕알고리즘]



##### 탐욕(Greedy) 알고리즘

* 최적화 문제를 해결하는 알고리즘

  최적값을 구하는 문제로 하나의 문제에 여러 해가 있을 수 있음

  The 최적해가 아닌 an 최적해를 구하는 것

* 여러 경우 중 하나를 결정해야 할 때마다 그 순간에 최적이라고 생각되는 것을 선택해나가는 방식으로 진행하여 최종적인 해답에 도달

* 각 선택의 시점에서 이루어지는 결정은 지역적으로는 최적이지만, 그 선택들을 계속 수집하여 최종적인 해답을 만들었다고 하여, 그것이 최적이라는 보장은 없음

* 탐욕 알고리즘이 항상 최적해를 구한다는 보장을 하기 위해서는 탐욕적 선택 속성과 최적 부분 구조에 대한 증명 필요

  * 탐욕적 선택 속성(Greedy Choice Property) 

    매 단계에서 이루어지는 탐욕적 선택이 항상 최적해로 갈 수 있다.

    탐욕적 선택은 항상 안전하다는 것을 증명

  * 최적 부분 구조(Optimal substructure property)

    하나의 탐욕적 선택을 하면 풀어야 할 하나의 하위 문제가 남는다.

    원문제의 최적해는 탐욕적 선택과 하위 문제의 최적해를 더한 것임을 증명

* 동작 과정

  * 해 선택

    부분문제의 최적해를 구해 부분 해 집합(Solution set)에 추가함

    현재 상태에서 최선이라고 여겨지는 선택을 추가함

  * 실행 가능성 검사

    새로운 부분 해 집합의 실행가능 여부 확인

    문제의 제약 조건 위반 여부 검사

  * 해 검사

    새로운 부분 해 집합이 문제의 해가 되는지 확인

    아직 전체의 문제의 해가 완성되지 않았다면 1의 해 선택부터 다시 시작

* 동전 거스름돈 문제

* 배낭문제

* 활동 선택 문제

  * 회의실 배정 문제

    동시에 회의가 열릴 수 있도록 최대한 많은 활동을 선택하는 문제

* 탐욕 기법과 동적 계획법의 비교

  |                          탐욕 기법                           |                     동적 계획법                      |
  | :----------------------------------------------------------: | :--------------------------------------------------: |
  | 단계마다 가장 좋아 보이는 것을 빠르게 선택함 -> 지역 최적 선택(local optimal choice) | 매 단계의 선택은 해결한 하위 문제의 해를 기반으로 함 |
  |       하위 문제 풀기전, (탐욕적) 선택이 먼저 이루어짐        |                 하위 문제 우선 해결                  |
  |                        Top-down 방식                         |                    Bottom-up 방식                    |
  |                  일반적으로  빠르고 간결함                   |                  좀더 느리고 복잡함                  |

* 베이비진 문제에 탐욕기법 적용

  * 6개의 숫자를 6자리의 정수값으로 입력, 카운트 배열에 저장

    Count 배열 : 0~9까지의 숫자의 빈도수를 저장하는 배열

  * Counts 배열의 각 원소를 체크하여 run과 triplet 및 baby-gin 여부 판단

  * run과 triplet 중 가능한 것 조사 -> 조사에 사용한 데이터 삭제 -> run과 triplet 중 가능한 것 조사



##### 대표적인 탐색 기법 알고리즘

* Prim
  * 그래프 이용
  * N개의 정점으로 구성된 최소 신장트리(MST)를 찾음
  * 트리 확장
* Kruskal
  * 그래프 이용
  * N개의 정점으로 구성된 최소 신장트리(MST)를 찾음
  * 서브 그래프 확장
* Dijkstra(다익스트라)
  * 그래프 이용
  * 주어진 정점에서 다른 정점에 대한 최단 경로 찾음

* Huffman coding
  * 문자열 이용
  * 문서의 압축을 위해 문자들의 빈도수에 따라 이진 트리 완성, 코드 값 부여



## [Learn > Course > Programming Advanced > 구현 > 분할정복]

##### 설계 전략

* 분할(divide) : 해결할 문제를 여러개의 작은 부분으로 나눔

  정복(Conquer) : 나눈 작은 문제를 각각 해결

  통합(Combine) : (필요하다면) 해결된 해답을 모음

* Top-down approach



##### 병합 정렬

* 여러개의 정렬된 자료의 집합을 병합하여 한 개의 정렬된 집합으로 만드는 방식

  -> 분할 정복 알고리즘 활용

  자료를 최소 단위의 문제까지 나눈 후에 차례대로 정렬하여 최종 결과를 얻어냄

  O(n log n)

* 분할 : 전체 자료 집합을 최소 부분집합이 될 때까지 분할작업을 계속 진행

  병합 : 2개의 부분집합을 정렬하면서 하나의 집합으로 병합, 모든 부분집합이 1개로 병합될때까지 반복

  

##### 퀵 정렬

* 주어진 배열을 두개로 분할하고, 각각을 정렬

  분할 시 기준 아이템(pivot item) 중심으로 이보다 작은것은 왼편, 큰것은 오른편에 위치시킴

  분할과정에서 선택된 피봇들이 자기자리를 찾음

  부분 정렬 후 병합 불필요

* Hoare파티션

  분할 자료들의 중간값에 가까운 값일수록 좋다

* Lomuto파티션

  i,j 모두 증가하면서 작업 수행

* O(nlogn)



##### 이진 검색

* 자료의 가운데에 있는 항목의 키 값과 비교하여 다음 검색의 위치를 결정하고 검색을 계속 진행하는 방법

  목적 키를 찾을때까지 이진검색을 순환적으로 반복 수행 - > 검색범위를 반으로 줄여가면서 보다 빠르게 검색 수행

  선행 조건 : 자료가 정렬 된 상태

  자료에 삽입이나 삭제가 발생했을 때 리스트가 정렬상태를 유지하도록 추가 작업 필요

* 검색 과정

  자료의 중앙에 있는 원소 선택

  중앙 원소 값과 찾고자 하는 목표 값 비교

  ​	목표 값 < 중앙 원소 값 : 자료 왼쪽 반에 대해 새로 검색 수행

  ​	목표 값 > 중앙 원소 값 : 자료 오른쪽 반에 대해 새로 검색 수행

  찾고자 하는 값을 찾을 때가지 과정 반복

* 분할 정복 사례

  * 병합 정렬

    외부 정렬의 기본이 되는 정렬 알고리즘

    Multi-Core CPU, 다수의 프로세서에서 정렬 알고리즘의 병렬화

  * 퀵정렬

    매우 큰 입력데이터에 대해 좋은 성능을 보임

  * 최근접 점의 쌍(Closest Pair)

    2차원 평면상의 n개의 점이 입력으로 주어질 때, 거리가 가장 가까운 한 쌍의 점을 찾는 문제

