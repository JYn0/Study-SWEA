# SW 문제해결 응용



## [Learn > Course > Programming Advanced > 구현 > 시작하기]



##### SW 문제 해결

* SW 문제 해결 역량은 프로그램 작성을 위한 많은 제약 조건들과 요구사항들을 이해하고 최선의 방법을 찾아내는 능력이 필요하다.
* 잘 정제된 추상적인 문제를 제시하고 이를 해결해 가면서 문제 해결 능력을 향상 시키는 훈련이 필요하다.



##### 알고리즘 복잡도

* 알고리즘을 설계하면 필요한 자원이 어르정도인지에 대한 효율성 분석이 필요하다.

  특히, 시간적 복잡도가 알고리즘의 효율성을 나타내는 주요한 요소이다.

* 시간 복잡도는 입력 크기에 대한 함수로 표기하고, 이 함수는 주로 여러개의 항을 가지는 다항식으로 표현한다.

* 이를 단순한 함수로 표한하기 위해 점근적 표기(Asymptotic Notation)를 사용한다.

  O(Big-Oh) , Ω(Big-Omega), Θ(Theta) 표기



##### 비트연산

| 연산자 |                   기능                   |      예      |
| :----: | :--------------------------------------: | :----------: |
|   &    |           비트단위로 AND 연산            | num1 & num2  |
|   \|   |            비트단위로 OR 연산            | num1 \| num2 |
|   ^    |   비트단위로 XOR연산 (같으면0 다르면1)   | num1 ^ num2  |
|   ~    | 단항 연산자, 피연산자의 모든 비트를 반전 |     ~num     |
|   >>   |    피연산자의 비트 열을 왼쪽으로 이동    |   num << 2   |
|   <<   |   피연산자의 비트 열을 오른쪽으로 이동   |   num >> 2   |



* << 정수 값을 왼쪽으로 시프트 : 곱한 결과

  2^n의 값을 가짐

  원소가 n개일 경우의 모든 부분집합의 수를 의미

  Power set(모든 부분 집합)

  * i & (1 << j)

    특정 위치의 비트 값이 1인지 0인지 판별하고 싶을 때 사용

    계산 결과 : i의 j번째 비트가 1인지 아닌지 의미

    ```C
    // 특정 위치의 비트값을 확인하는 수식
    void BitPrint(char i){
        for(int j=7; j>=0; j--){
            putchar((i & (1 << j)) ? '1' : '0');
            // print("%d", (i >> j) & 1);
        }
    }
    void main(void){
        char i;
        for(i=-5; i<6; i++){
            printf("%3d = ", i); // 십진수 출력
            BitPrint(i); // 이진수 출력
            putchar('\n');
        }
    }
    ```

  * 4바이트 크기의 인티저형 변수에 저장된 값들을 한 바이트씩 읽어서 비트형태로 출력

    ```C
    void main(void){
        char *p;
        char a = 0x10;
        int x = 0x01020304, i;
        printf("%d = ", a);
        p = &a;
        Bbit_print(*p);
        putchar('\n');
        printf("0%X = ", x);
        p = (char *) &x;
        for(i=0; i<4; i++){
            Bbit_print(*p++);
        }
        putchar('\n');
    }
    ```

* 엔디안(Endianness)

  컴퓨터의 메모리와 같은 일차원의 공간에 여러개의 연속된 대상을 배열하는 방법

  하드웨어(HW) 아키텍처마다 다름

  속도향상을위해 바이트단위와 워드단위변환 연산 시 올바로 이해하지 않으면 오류 발생

  * 빅 엔디안(Big-endian)

    보통 큰 단위가 앞에 나옴(네트워크)

  * 리틀 엔디안(Little-endian)

    작은 단위가 앞에 나옴(대다수의 데스크탑 컴퓨터)
  
* Byte Alignment

  프로세서의 성능 향상 -> 주소버스가 4의 배수형태의 주소만 access

  어떤 객체(4byte)가 4의 배수형 주소에 있지 않다면 메모리 access를 2번 해야함

  * 변수 별 저장 가능한 주소의 번지 패턴

    1byte 형: 모든 주소 번지에 기록 가능

    2byte 형: 2byte boundary에 정렬4

    byte 형: 4byte boundary에 정렬

    Double(8byte) 형: windows에서는 8byte, 리눅스에서는 4byte boundary

  * Structrue Byte Padding

    구조체의 멤버들 사이에 임의의 공간이 생기는 현상(padding byte)

    구조체의 경우 멤버 중 가장 큰 데이터 타입의 배수 값으로 크기가 결정

    구조체 멤버들의 순서를 잘 배치하면 필요한 메모리의 크기를 줄일 수 있음

* XOR

  배타적 논리합을 구하는 연산자

  비트 연산자 ^를 두번 연산하면 처음 값 반환



##### 진수

* 2진수, 8진수, 10진수, 16진수

* 컴퓨터에서 음의 정수 표현 방법

  * 1의 보수

    부호와 절대값으로 표현된 값을 부호 비트를 제외한 나머지 비트들을 0은 1로, 1은 0으로 변환

    -6 : 1000 0000 0000 0110 : 부호와 절대값 표현

    -6 : 1111 1111 1111 1001 : 1의 보수 표현

  * 2의 보수

    1의 보수방법으로 표현된 값의 최하위 비트에 1을 더함

    16 : 1111 1111 1111 1010 : 2의 보수 표현



##### 실수

* 컴퓨터에서 실수의 표현 방법

  부동 소수점(floating-point) 표기법 : 소수점의 위치를 고정시켜 표현하는 방식

  실수를 저장하기 위한 형식

  * 단정도 실수(32비트)

    부호 1비트 + 지수 8비트 + 가수 23비트

  * 배정도 실수(64비트)

    부호 1비트 + 지수 11비트 + 가수 52비트

  * 가수부(mantissa) : 실수의 유효 자릿수들을 부호화된 고정 소수점으로 표현한 것

    지수부(exponent) : 실제 소수점의 위치를 지수 승으로 표현한 것

  * 단정도 실수의 가수 부분을 만드는 방법

    예 1001.0011

    1. 정수부의 첫번째 자리가 1이 되도록 오른쪽으로 시프트 -> 0001.0010011
    2. 소수점 이하를 23비트로 만듦 -> 001.00100110000000000000000
    3. 소수점 이하만 가수 부분에 저장 -> 00100110000000000000000
    4. 지수 부분은 시프트 한 자릿수 만큼 증가 또는 감소 -> 1.0010011 X 2^3

  * 단정도 실수의 지수 부분을 만드는 방법

    지수부에는 8비트 배정(256개의 상태를 나타낼 수 있음)

    숫자로 0~255까지 표현 가능, 음수 값을 나타낼 수 있어야 하므로 익세스(excess) 표현법 사용

    ​	익세스(excess) 표현법 : 지수부의 값을 반으로 나누어 그 값을 0으로 간주하여 음수지수와 양수지수를 표현하는 방법

* 유효 숫자

  컴퓨터는 실수를 근사적으로 표현

  ​	정확한 십진수의 실수 값을 이진수로 표현할 수 없음

  ​	이진수로 표현할 수 없는 실수는 근사 값으로 저장

  ​	작은 오차가 계산 과정에서 다른 결과를 가져올 수 있음 -> 오차에 항상 주의

  실수 자료형 표현에서 가능한 유효 숫자의 자릿수를 알아 두는 게 좋음

  ​	32비트 실수형 유효자릿수(십진수) -> 6

  ​	64비트 실수형 유효자릿수(십진수) -> 15

